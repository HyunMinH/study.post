# 유연한 설계

- 유연한 설계를 위해 의존성을 관리하는 유용한 몇 가지 원칙과 기법을 익힐 필요가 있다.

## 의존성과 결합도

- 바람직한 의존성은 재사용과 관련이 있다. 

    - 어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직 못한 것이다.

    - 바람직한 못한 의존성은 느슨한 결합도를 가진다.

## 지식이 결합을 낳는다.

- 결합도는 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.

    - Movie가 PercentDiscountPolicy에 의존하는 것 보다 DiscountPolicy에 의존하는 게 더 결합도가 약하다.

## 추상화에 의존하라

- 느슨한 결합을 위해 추상화에 의존하도록 하자

- 아래로 갈 수록 클라이언트가 알아야 하는 지식의 양이 적어짐 -> 결합도 느슨해진다.

    - 구체 클래스 의존성

    - 추상 클래스 의존성

    - 인터페이스 의존성

## 명시적인 의존성

- 결합도를 느슨하게 만들기 위해서는 인스턴스 변수의 타입을 추상 클래스나 인터페이스로 선언하는 것만으로는 부족하다.

- 클래스 안에서 **구체 클래스**에 대한 모든 의존성을 제거해야 한다. 이를테면 구체 클래스를 생성하는 것 같은

- 의존성의 대상을 생성자의 인자로 전달받는 다는 건 -> 의존한다는 사실을 퍼블릭 인터페이스에 드러내는 것이다. 이를 명시적인 의존성이라고 한다.

    - 의존성은 명시적으로 표현되어야 한다. 그래야 설계가 유연하고 재사용 가능해진다.

    - 그렇지 않으면 클래스를 다른 컨텍스트에서 재사용하기 위해 내부 구현을 직접 변경해야 할 수 있다.

## new는 해롭다

- new를 잘못 사용하면 결합도가 극단적으로 높아진다.

    - new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 함.

    - new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다. (알아야 하는 지식의 양이 늘어남)

## 표준 클래스에 대한 의존은 해롭지 않다.

- 원래 의존성이 불편한 이유는 그것이 항상 변경에 대한 영향을 암시하기 때문

- 표준 클래스는 바뀔 가능성이 거의 없음.
